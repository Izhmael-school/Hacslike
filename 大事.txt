- 設計
  - クラスやコンポーネントの責務が適切か  単一責任の原則（SRP）が守られているか？

- 可読性
  - 他人や未来の自分が読んで理解しやすいか 命名・コメント・整理が明確か？

- 保守性
  - 変更に強いか  同じ処理を複数箇所に書いていないか？依存が強すぎないか？

- パフォーマンス
  - Unity特有の処理負荷を意識しているか      Updateの処理が重くないか？GCが多発していないか？

- 安全性・安定性
  - バグや例外に強いか     nullチェック、エラー処理、範囲外アクセスが安全か？

●設計・構造チェック

クラス・コンポーネントの責務は明確か？
　一つのクラスが複数の役割（UI更新・データ管理・入力処理など）をしていないか？
　神クラスになっていないか
　　PlayerController が入力とUI更新とセーブを全部やっていない？
MonoBehaviourの使い方が適切か？
ロジックやデータをMonoBehaviourに詰め込みすぎていないか？
ScriptableObjectで設定値・データを分離できないか？
依存関係の向きは整理されているか？
　下位（モデル）層が上位（UI）層に依存していないか？
直接参照よりもイベント／UnityEvent／Observerパターンで疎結合にできないか？
インターフェースクラスを用いて実装できているか？

●コーディングスタイル・可読性チェック

命名が意味を伝えているか？
　hp より currentHealth のほうが意図が明確。
メソッド名は動詞から始める（例：TakeDamage()、ResetPosition()）。
コメントと命名のバランス
　「なぜそうするのか」をコメントで書く。
　「何をしているか」はコードで伝わるようにする。
　インデント・空行・並び順
クラス内メンバを整理：SerializeField → public → private
関連する処理を近くに配置する。

●再利用性・保守性チェック

重複コードを減らせるか？
同じ処理を複数スクリプトで書いていないか？
共通ロジックを Utility クラスや拡張メソッドにまとめられるか？
マジックナンバーを避けているか？
if (hp < 10) → if (hp < criticalHealthThreshold)
値を SerializeField で公開
ScriptableObjectで管理。
変更に強い設計になっているか？
プレイヤーのステータスを変更しても他のクラスが壊れない？
新しい敵を追加するとき、コードを大きく変更しなくて済む？
assert対応として、Assertionsを用いて自身の意図をコードに反映させているか？

●Unity特有の注意点

Update()内が重くないか？
頻繁に呼ばれる処理はCoroutineやイベントに移動できないか？
キャッシュできる参照を毎回GetComponentしていないか？
インスタンス管理
シングルトンの乱用に注意（GameManager が万能神になっていない？）
DontDestroyOnLoadの使い方に気をつける。
オブジェクトプールの利用
Instantiate/Destroyが多いとGCが重くなる。
　弾・敵・エフェクトなどはプールで管理。